# Claude Code Project Guidelines

This file contains guidelines for Claude Code when working on this project.

## Project Configuration

- **Rust Edition**: 2024 (do not change this)

## TinyCC Reference Rule

**IMPORTANT**: When encountering problems or implementing new features:

1. **First check TinyCC's approach**: Before implementing a solution, investigate how TinyCC (especially `tccpp.c`) handles the same problem
2. **Document findings**: Explain how TinyCC solves the problem before proposing a solution
3. **Follow TinyCC patterns**: Prefer solutions that align with TinyCC's approach for consistency

The TinyCC source code is located in the `tinycc/` directory.

## Development Workflow

### Signature Approval Rule

**IMPORTANT**: Before implementing any new module or making significant changes:

1. **Present Signatures First**: Before creating a new `.rs` file, present the public API (structs, enums, function signatures) to the user for review
2. **Wait for Approval**: Do not start implementation until the user explicitly approves the signatures
3. **Apply to Changes**: When making major changes to existing modules, present signature-level changes first

### Phase-based Development

This project is developed in phases. Each phase should:
1. Start with signature approval
2. Implement the approved design
3. Test and verify before moving to the next phase

### Current Phase Structure

- **Phase 1**: Lexer foundation (completed)
- **Phase 2**: Preprocessor (completed)
- **Phase 3**: Parser + S-expression dump (completed)
  - `ast.rs` - Abstract Syntax Tree definitions
  - `parser.rs` - C language parser
  - `sexp.rs` - S-expression output
  - `main.rs` - CLI binary for S-expression dump

### Commit Guidelines

- Commit after each phase is complete
- Use descriptive commit messages explaining the changes

### Documentation Updates

When making changes to `src/macrogen.rs` (especially `generate()` function):
- Update `doc/macrogen-flow.md` to reflect the changes
- Keep the processing flow description in sync with the actual code

### Architecture Documentation Updates

**IMPORTANT**: After completing any significant implementation task:

1. **Check if architecture docs need updates**: Review `doc/architecture*.md` files to see if the changes affect documented structures or flows
2. **Update affected documentation**: If the task modified:
   - Struct fields or enum variants → Update the corresponding architecture doc
   - Processing flows or algorithms → Update flow diagrams or descriptions
   - New methods or APIs → Add to the relevant method tables
3. **Key architecture files**:
   - `doc/architecture-semantic-type-inference.md` - Type inference, SemanticAnalyzer, TypeRepr
   - `doc/architecture-rust-codegen.md` - Code generation, RustCodegen, CodegenDriver
   - `doc/architecture-macro-expansion-control.md` - Macro expansion rules
   - `doc/architecture-inline-function-processing.md` - Inline function handling
   - `doc/architecture-thx-dependency.md` - THX (my_perl) dependency detection

### Test Files Location

Temporary test files should be placed in `./tmp/` directory, not `/tmp`.

### Plan Files Location

When creating implementation plans or design documents, place them in `doc/plan/` directory (not in `~/.claude/plans/`).

### Integration Test Files

- **bindings.rs**: The latest `bindings.rs` generated by the integration test is at `samples/bindings.rs`. Use this file for checking function availability, not the one in the build directory.
- **Integration test script**: `~/blob/libperl-rs/12-macrogen-2-build.zsh`
- **Build error log**: `tmp/build-error.log`
- **Generated macro bindings**: `tmp/macro_bindings.rs`

## CLI Usage

### Testing with samples/xs-wrapper.h

The recommended way to test with `samples/xs-wrapper.h` is using the `--auto` option:

```bash
# Parse and output S-expression (recommended)
cargo run -- --auto samples/xs-wrapper.h

# Streaming mode with source context on errors
cargo run -- --auto --streaming samples/xs-wrapper.h

# Preprocess only (like gcc -E)
cargo run -- --auto -E samples/xs-wrapper.h

# GCC-compatible output format (for diff comparison)
cargo run -- --auto -E --gcc-format samples/xs-wrapper.h
```

The `--auto` option automatically retrieves include paths and defines from Perl's `Config.pm`.

### Testing Rust Function Generation (--gen-rust)

To test macro-to-Rust function generation with production data:

```bash
cargo run -- samples/xs-wrapper.h --auto --gen-rust --bindings samples/bindings.rs
```

This command:
- Uses `samples/xs-wrapper.h` as input
- Reads type information from `samples/bindings.rs`
- `--auto` automatically reads API documentation from `apidoc/embed.fnc`
- Generates Rust functions from C macros

### Testing Macro Type Inference (--infer-macro-types)

```bash
cargo run -- --auto --infer-macro-types samples/xs-wrapper.h --bindings samples/bindings.rs
```

This command:
- Uses `samples/xs-wrapper.h` as input
- Reads Rust type bindings from `samples/bindings.rs` (required for function signatures)
- `--auto` automatically reads API documentation (required for macro/function type hints)
- Performs type inference on all macros and outputs statistics

### Manual Options (alternative)

If `--auto` doesn't work, use explicit options:

```bash
cargo run -- -E \
  -I/usr/include \
  -I/usr/include/linux \
  -I/usr/lib/gcc/x86_64-redhat-linux/15/include \
  -D_REENTRANT \
  -D_GNU_SOURCE \
  -I/usr/local/include \
  -D_LARGEFILE_SOURCE \
  -D_FILE_OFFSET_BITS=64 \
  -I/usr/lib64/perl5/CORE \
  -D__linux \
  -D__linux__ \
  -D__unix \
  -D__unix__ \
  -D__x86_64 \
  -D__x86_64__ \
  -Dlinux \
  -Dunix \
  -D__gnu_linux__ \
  -D__STDC__ \
  -D__LP64__ \
  -D_LP64 \
  samples/xs-wrapper.h
```

## Implemented Features

### GCC Extensions Supported

- `__attribute__((...))` - on functions, parameters, struct members, declarations
- `__extension__` - ignored
- `__asm__` / `asm` / `__asm` - inline assembly (skipped in parsing)
- `__typeof__` / `typeof` - typeof operator
- `__alignof__` / `__alignof` - alignof operator
- `__signed__` - signed keyword variant
- `bool` (C23/GCC) - boolean type
- `_Bool` - C99 boolean type
- `_Complex` - complex number type
- `_Float16`, `_Float32`, `_Float64`, `_Float128`, `_Float32x`, `_Float64x` - extended float types
- `__int128` - 128-bit integer type
- `_Thread_local` / `__thread` - thread-local storage (ignored)
- `({ ... })` - statement expressions
- `_Pragma(...)` - pragma operator (defined as empty macro)

### Preprocessor Features

- Object and function-like macros
- `#if`, `#ifdef`, `#ifndef`, `#elif`, `#else`, `#endif`
- `#include` and `#include_next`
- `#define` and `#undef`
- `#pragma` (ignored)
- `#error` and `#warning`
- Token pasting (`##`) and stringification (`#`)
- Variadic macros (`__VA_ARGS__`, `##__VA_ARGS__`)
- Predefined macros (`__FILE__`, `__LINE__`, etc.)
- Macro argument prescanning (C standard compliant)

### Macro Expansion Location Tracking

When errors occur in macro-expanded code, the error location points to where the macro is **used**, not where it is **defined**. This makes debugging easier.

### Macro Tracking CLI Options

- `--emit-macro-markers`: Output MacroBegin/MacroEnd marker tokens during preprocessing (for debugging)
- `--macro-comments`: Add definition location comments to generated Rust code (with `--gen-rust`)

Example with macro comments:
```bash
cargo run -- samples/xs-wrapper.h --auto --gen-rust --bindings samples/bindings.rs --macro-comments
```

This generates code like:
```rust
// Defined at: sv.h:123
#[inline]
pub unsafe fn SvFLAGS(sv: *mut SV) -> U32 {
    (*sv).sv_flags
}
```

## Code Generation Goals

### Consistency Principle

**Code generation must behave consistently for both C inline functions and C macro functions.**
The same consistent behavior must also apply to function call arguments.

### Macro Handling Rules

Rules for handling macros in generated code:

| Macro Type | Condition | Action |
|------------|-----------|--------|
| Object macro (constant) | Corresponding constant exists in Rust | Output as Rust constant |
| Object macro (constant) | No Rust counterpart | Expand inline |
| Function macro | **Not registered** in special dictionaries | Preserve as function call |
| Function macro | Registered in `ExplicitExpandSymbols` | Expand (e.g., `SvANY`, `SvFLAGS`) |
| assert family | `NoExpandSymbols` / `wrapped_macros` | Ignore `DEBUGGING` state, process arguments and generate as `assert!` |

### Key Implication

- **Default behavior is "preserve function macros"**
- Expansion only for explicitly specified macros
- This rule should apply to both **Preprocessor** (for inline functions) and **TokenExpander** (for macros)

### Current Implementation Gap

| Processing Engine | Target | Default for Function Macros |
|-------------------|--------|----------------------------|
| `TokenExpander` | Macros | Preserve ✓ |
| `Preprocessor` | Inline functions | **Expand** ✗ ← needs fix |

The `Preprocessor`'s `wrapped_macros` argument expansion needs to behave equivalently to `TokenExpander`.

## Current Status

- **xs-wrapper.h parsing**: Successfully parses declarations
- **All tests passing**: 52 tests pass
